\section{测试}
    \setlength\parskip{0.3\baselineskip}
    \subsection{测试范围}
    考虑到项目上线的需要，测试部分除了单元测试以外还需要进行压力测试。前者主要确保用户的合法操作能得到预期的结果，非法的操作不至于影响项目运行安全或者访问无权限访问无权限访问的数据。
    \subsection{测试方法}
        \subsubsection{路由函数测试}
            \begin{itemize}
            \item \textbf{测试原理}
            
            \quad \quad 从用例的角度考虑，合理的测试方法是通过访问路由函数来模拟用户所有可能的操作。考虑到用户完全可以通过修改前端，甚至是直接使用脚本发出一些非法的请求。测试中http请求中的数据不应当完全依赖于前端的规定。亦即，对于每个路由函数，我们需要明确在它运行前可以确保什么一定是成立的，对于以外的东西需要在路由函数中检测；在运行后，我们需要明确在各种情况下什么东西一定会完成。

            \quad \quad 测试时主要采用判定覆盖的方法，对于主要的路由函数，同时采用了条件覆盖的方法。
        
            \item \textbf{代码内容}
            
            \quad \quad 路由函数在./routes目录下，对于主要的文件，我们使用 python 按照各个用例编写了脚本。脚本储存在./complex\_test/routes\_test中。在该目录下，同时存储了测试中需要用到的部分数据，例如vhdl代码和仿真文件。
            
            \quad \quad 在部分用例中，测试是从登录，创建项目开始，直到本用例的核心路由函数。对于每个用例，我们都给出了完全合法的访问的各种情况，以及非法的部分情况。后者主要是根据路由函数的代码以及常见的错误进行构造的。例如：我们假设用户试图通过各种奇怪的手段访问其它用户的项目，尽管阻止这种行为看似简单，但是仍然需要完善的用户管理和权限管理系统才能做到。
            
            \quad \quad 通过比对脚本中 http 请求的结果与预期的结果来判断是否通过了测试。由于报错时输出并没有统一格式，以及没有建立好测试代码与前端代码的联系，这种做法是缺乏可维护性的。测试过程中会将每个路由函数名，用例编号，测试结果逐个输出，通过即显示 true，未通过即显示 false。可以由此确定为通过的用例的位置。
            
            \quad \quad 在代码未完善之前，许多非法的操作是不可逆的，因而在路由函数测试结束后没有恢复系统本身的状态。相对应的，脚本中有变量test\_times，每次运行时加1，用于在每次测试中生成不同的项目名。
            
            \end{itemize}
        \subsubsection{压力测试}
            
            为了上线的需要，需要对项目进行压力测试。由于 Node.js 本身就具有高并发性的优势，故而用户的需要，即 60 人左右的并发规模是完全可以满足的。我们没有对并发性做出进一步的优化。但是仍然需要一定的测试进行检验。
            
            我们同样使用 python 脚本多线程访问，它们位于./complex\_test/stress\_test 目录下，主要包括两个文件，分别是针对两种主要的项目类型：文本编辑类型和拖拽类型进行测试。它们模拟了用户登录，创建项目，修改项目（上传文件，更改激励信号等），后端仿真，读取结果的过程。
            
            测试中发现同时的连续访问将导致项目无法正确地处理所有的请求，具体原因尚未找到。由于测试脚本中每个线程内部的请求是阻塞的，也就是说在下一个请求发出前，上一个请求的响应已经收到，推测是项目自身的原因，可能是在响应发出后，还有部分后续工作未完成，导致连续的接下来的访问无法得到正确结果。因而我们使用了一组变量来控制访问的间隔。结果将在下文详述
    \subsection{测试结果}
        \subsubsection{路由函数测试结果}
            在测试过程中发现了许多 bug，它们在代码中的相应位置都有注释。这些问题目前都已经被修复。
        \subsubsection{压力测试结果}
            这部分结果是项目尚未部署到服务器上时测试的，我们模拟的是最复杂的情况，即期末考试的完整流程，并发规模为 60。但是项目无法正确地处理同时的 60 个线程访问，在这种情况下只有约 20\% 的项目能从始自终完全正确地处理。要完全正确地处理，需要两个条件，单一线程的某些相邻请求之间需要一定的间隔（主要是创建项目后需要等待约 0.2 秒），多个线程的请求之间需要一定的间隔。对于后者，这里采取的办法是在每个线程的启动时，给予一定的时间间隔。从这个意义上而言，我们的项目并没有完全达到并发性的要求。但是，我们的项目能在20秒内处理完全部的工作。考虑到实际情况难以达到如此高密度的访问以及项目部署到服务器后的性能提升，我们的项目是能达到要求的。